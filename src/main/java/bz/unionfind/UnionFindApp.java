package bz.unionfind;

/**
 * 并查集应用
 */
public class UnionFindApp {
    /**
     * 765. 情侣牵手
     * N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。
     * 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。
     *
     * 一次交换可选择任意两人，让他们站起来交换座位。
     * 人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是(0,1) ，第二对是(2,3) ，以此类推，最后一对是(2N-2, 2N-1) 。
     *
     *  思路： 以情侣对为单位进行分析：
     *    当有两对情侣相互坐错了位置，ta们两对之间形成了一个环。需要进行一次交换，使得每队情侣独立（相互牵手）
     *    如果三对情侣相互坐错了位置，ta们三对之间形成了一个环，需要进行两次交换，使得每队情侣独立（相互牵手）
     *    如果四对情侣相互坐错了位置，ta们四对之间形成了一个环，需要进行三次交换，使得每队情侣独立（相互牵手）
     *  也就是说，如果我们有 k 对情侣形成了错误环，需要交换 k-1 次才能让情侣牵手。
     *
     *  于是问题转化成 N 对情侣中，有多少个这样的环（即根节点个数），情侣对个数减去环的个数就是交换次数，可以用并查集来求解。
     *  比如有3个环， (0,1,2,3), (4), (5)，第一个环四对情侣，需要交换三次， 第二、三个环，只有一对情侣，不需要交换。
     *  也就是所有环中 排除根元素 的元素个数之和。
     *
     *  例如 {0,1,2,3}，除以2即是情侣对编号: {0/2, 1/2, 2/2, 3/2}={0,0, 1,1}, 相邻union后0和1没有形成环
     *  需要交换: {0,2,1,3}, 除以2即是情侣对编号: {0/2, 2/2, 1/2, 3/2}={0, 1, 0,1}，相邻union后0和1形成了环。
     */
    public int minSwapsCouples(int[] row) {
        int n = row.length;
        UnionFind uf = new UnionFind(n / 2);

        for (int i = 0; i < n; i += 2) {
            // 情侣对编号
            uf.union(row[i] / 2, row[i + 1] / 2);
        }
        // 所有环中 排除根元素 的元素个数之和
        return  n / 2 - uf.ringCntOptimized();
    }
}
